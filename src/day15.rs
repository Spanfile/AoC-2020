use aoc_runner_derive::{aoc, aoc_generator};
use std::collections::HashMap;

#[aoc_generator(day15)]
pub fn generator(input: &str) -> Vec<i32> {
    input.split(',').map(|s| s.parse().unwrap()).collect()
}

#[aoc(day15, part1)]
pub fn part1(input: &[i32]) -> i32 {
    solve(input, 2020)
}

#[aoc(day15, part2)]
pub fn part2(input: &[i32]) -> i32 {
    solve(input, 30000000)
}

fn solve(input: &[i32], upper: usize) -> i32 {
    let mut numbers = input
        .iter()
        .enumerate()
        .map(|(i, v)| (*v, (1, i + 1)))
        .collect::<HashMap<_, _>>();
    let mut last_number = *input.last().unwrap();

    for turn in input.len() + 1..=upper {
        let (times_spoken, last_spoken) = *numbers.get(&last_number).unwrap();
        if times_spoken == 1 {
            // println!("turn {}: {} has been spoken only once, saying 0", turn, last_number);
            last_number = 0;
        } else {
            // print!(
            //     "turn {}: {} has been spoken more than once, last in turn {}, saying ",
            //     turn, last_number, last_spoken,
            // );
            numbers.entry(last_number).and_modify(|(_, t)| {
                *t = turn - 1;
            });
            last_number = (turn - 1 - last_spoken) as i32;
            // println!("{}", last_number);
        }

        numbers
            .entry(last_number)
            .and_modify(|(s, _)| {
                *s += 1;
            })
            .or_insert((1, turn));
    }

    last_number
}
